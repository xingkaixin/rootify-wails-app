# 团队协作功能技术讨论纪要

**日期**: 2024-09-29
**参会人员**: 凯哥, Claude Code
**主题**: 词根库团队协作功能技术方案讨论

## 1. 原始需求

### 1.1 初始提案
- **功能需求**: 在现有SQLite本地存储基础上，增加MySQL数据库连接选项
- **目标场景**: 团队协作，多人共同使用统一的词根库
- **技术方案**: 用户可选择连接MySQL数据库来管理词根

### 1.2 需求分析
- **真实需求**: 团队协作，数据共享
- **隐含需求**: 多用户编辑，数据同步，冲突处理

## 2. 技术分析

### 2.1 当前架构评估
- **技术栈**: Wails + React + SQLite
- **数据模型**: 简单键值对（中文词根 → 英文对应）
- **部署模式**: 桌面应用，个人用户

### 2.2 MySQL方案评估

#### 优点
- 标准数据库，支持并发访问
- 成熟的数据同步机制

#### 缺点
- **过度设计**: 桌面应用引入服务器依赖
- **配置复杂**: 用户需要设置连接字符串、用户名密码
- **部署困难**: 需要MySQL服务器环境
- **维护成本**: 连接池、错误处理、数据迁移
- **破坏简洁性**: 违背桌面应用的零配置原则

## 3. 替代方案设计

### 3.1 方案演进

#### 第一轮：文件同步方案
- **方案**: 共享CSV文件 + 自动同步
- **优点**: 简单、零依赖、零配置
- **局限**: 仅支持单向同步（只读共享）

#### 第二轮：多向同步挑战
- **发现问题**: 多用户编辑时的冲突处理
- **复杂度**: 冲突检测、合并策略、用户体验

#### 第三轮：分层存储方案（最终推荐）

### 3.2 最终推荐方案：分层存储 + 个人优先

#### 架构设计
```
┌─────────────────┐    ┌─────────────────┐
│   共享词根库     │    │   个人词根库     │
│   (只读同步)     │    │   (可编辑)       │
└─────────────────┘    └─────────────────┘
         │                       │
         └───────────┬───────────┘
                     │
             ┌───────────────┐
             │   合并视图     │
             │ (共享+个人)    │
             │ 个人覆盖共享   │
             └───────────────┘
```

#### 核心特性
1. **共享词根库**: 团队统一维护的基础词根，只读同步
2. **个人词根库**: 每个人的个性化修改，本地存储
3. **合并视图**: 共享 + 个人，个人修改覆盖共享版本
4. **冲突处理**: 个人优先策略，无复杂冲突解决

#### 技术实现
```go
type App struct {
    sharedRoots   map[string]string  // 共享词根（只读）
    personalRoots map[string]string  // 个人词根（可编辑）
}

// 数据合并：个人优先
func (a *App) getMergedRoots() map[string]string {
    merged := make(map[string]string)
    for k, v := range a.sharedRoots {
        merged[k] = v
    }
    for k, v := range a.personalRoots {  // 个人覆盖共享
        merged[k] = v
    }
    return merged
}
```

## 4. 决策依据

### 4.1 为什么选择分层存储

#### 符合"好品味"原则
- **消除特殊情况**: 无复杂冲突处理
- **简洁实现**: 约120行代码 vs MySQL的500+行
- **零破坏性**: 不影响现有单机用户

#### 符合实际需求
- **词根数据特性**: 更新频率低，冲突概率小
- **团队协作模式**: 基础词根统一，个人可定制
- **用户体验**: 编辑立即生效，无冲突提示

#### 技术优势
- **零依赖**: 不需要额外服务器
- **零配置**: 用户只需设置同步源
- **高性能**: 本地操作，无网络延迟

### 4.2 为什么拒绝MySQL

#### 违背实用主义
- **理论完美 vs 实际需要**: MySQL功能远超需求
- **复杂度不匹配**: 火箭筒打蚊子
- **部署负担**: 桌面应用不应依赖外部数据库

#### 破坏简洁性
- **配置复杂性**: 连接字符串、认证、网络
- **维护负担**: 连接池、超时、错误处理
- **用户体验**: 从零配置变成复杂配置

## 5. 实现计划

### 5.1 第一阶段：基础同步功能
- [ ] 实现共享词根库同步（文件/Git/HTTP）
- [ ] 实现分层存储架构
- [ ] 实现个人优先合并策略

### 5.2 第二阶段：协作功能
- [ ] 实现个人修改提交到共享库
- [ ] 添加同步状态显示
- [ ] 实现冲突标记（可选）

### 5.3 第三阶段：高级功能
- [ ] 实现自动同步
- [ ] 添加同步历史
- [ ] 支持多种同步源

## 6. 关键洞察

### 6.1 技术洞察
- **SQLite在桌面应用中比MySQL更合适**: 零配置、高性能、无依赖
- **词根数据天然适合文件格式**: CSV/JSON都是理想选择
- **团队协作的核心是数据一致性，不是数据库类型**

### 6.2 架构洞察
- **分层存储完美解决90%的协作需求**
- **个人优先策略最符合桌面应用的用户体验**
- **复杂冲突处理会破坏应用的简洁性**

### 6.3 产品洞察
- **真正的需求是数据共享，不是数据库切换**
- **保持桌面应用的零配置特性是关键**
- **简单方案往往比复杂方案更实用**

## 7. 后续讨论点

1. **同步频率**: 手动同步 vs 自动同步
2. **权限管理**: 谁可以修改共享库
3. **数据备份**: 同步失败时的恢复机制
4. **性能优化**: 大数据量时的同步策略

---

**记录人**: Claude Code
**审核人**: 凯哥
**下次讨论**: 待定
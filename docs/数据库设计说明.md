# 金融词根翻译系统 - 数据库设计说明

## 数据库概述

金融词根翻译系统使用 SQLite3 作为数据存储方案，设计简洁高效，满足词根管理和翻译功能的需求。

## 数据库文件信息

**文件位置**: `rootify.db` (应用数据目录)
**数据库引擎**: SQLite3
**字符编码**: UTF-8

## 表结构设计

### 核心表: word_roots (词根表)

**创建语句**:
```sql
CREATE TABLE IF NOT EXISTS word_roots (
    chinese TEXT PRIMARY KEY,
    english TEXT NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
CREATE INDEX IF NOT EXISTS idx_chinese ON word_roots(chinese);
```

#### 字段详细说明

| 字段名 | 数据类型 | 约束 | 说明 |
|--------|----------|------|------|
| chinese | TEXT | PRIMARY KEY, NOT NULL | 中文词根，作为主键确保唯一性 |
| english | TEXT | NOT NULL | 英文对应翻译，不能为空 |
| created_at | DATETIME | DEFAULT CURRENT_TIMESTAMP | 记录创建时间，自动设置 |
| updated_at | DATETIME | DEFAULT CURRENT_TIMESTAMP | 记录更新时间，自动设置 |

#### 索引设计

**主索引**: chinese 字段作为主键，自动创建索引
**辅助索引**: `idx_chinese` 索引，优化查询性能

**索引创建语句**:
```sql
CREATE INDEX IF NOT EXISTS idx_chinese ON word_roots(chinese);
```

## 数据操作实现

### 1. 数据库初始化

**文件位置**: `app.go` - `initDB()` 方法

**初始化流程**:
1. 获取应用数据目录
2. 打开/创建数据库文件
3. 执行表创建和索引创建语句
4. 返回数据库连接对象

**关键代码**:
```go
func (a *App) initDB() error {
    appDataDir, err := getAppDataDir()
    dbPath := filepath.Join(appDataDir, "rootify.db")
    db, err := sql.Open("sqlite3", dbPath)

    // 创建表和索引
    createTableSQL := `...` // 完整的创建语句
    _, err = a.db.Exec(createTableSQL)
    return nil
}
```

### 2. CRUD 操作实现

#### 2.1 查询操作 (Read)

**获取所有词根**:
```go
func (a *App) GetAllRoots() (map[string]string, error) {
    a.mu.RLock()  // 读锁
    defer a.mu.RUnlock()

    rows, err := a.db.Query("SELECT chinese, english FROM word_roots ORDER BY chinese")
    // 遍历结果构建map
}
```

**SQL 查询**: `SELECT chinese, english FROM word_roots ORDER BY chinese`

#### 2.2 插入/更新操作 (Create/Update)

**添加词根**:
```go
func (a *App) AddRoot(chinese, english string) error {
    a.mu.Lock()  // 写锁
    defer a.mu.Unlock()

    _, err := a.db.Exec(
        "INSERT OR REPLACE INTO word_roots (chinese, english, updated_at) VALUES (?, ?, CURRENT_TIMESTAMP)",
        chinese, english,
    )
}
```

**SQL 语句特点**:
- 使用 `INSERT OR REPLACE` 实现 upsert 功能
- 自动更新 `updated_at` 时间戳
- 新记录自动设置 `created_at`

#### 2.3 删除操作 (Delete)

**删除词根**:
```go
func (a *App) DeleteRoot(chinese string) error {
    a.mu.Lock()
    defer a.mu.Unlock()

    _, err := a.db.Exec("DELETE FROM word_roots WHERE chinese = ?", chinese)
}
```

**清空所有词根**:
```go
func (a *App) ClearAllRoots() error {
    a.mu.Lock()
    defer a.mu.Unlock()

    _, err := a.db.Exec("DELETE FROM word_roots")
}
```

### 3. 批量操作实现

#### 3.1 批量导入

**事务处理模式**:
```go
func (a *App) ImportRoots(roots map[string]string) error {
    a.mu.Lock()
    defer a.mu.Unlock()

    tx, err := a.db.Begin()
    defer tx.Rollback()  // 确保事务回滚

    stmt, err := tx.Prepare("INSERT OR REPLACE INTO word_roots ...")

    for chinese, english := range roots {
        _, err := stmt.Exec(chinese, english)
    }

    return tx.Commit()  // 提交事务
}
```

**性能优化**:
- 使用事务确保原子性
- 预编译语句提高执行效率
- 批量处理减少数据库往返

#### 3.2 数据导出

**CSV 格式生成**:
```go
func (a *App) ExportRoots() (string, error) {
    var csvContent string
    csvContent = "中文词根,英文对应\n"

    for rows.Next() {
        csvContent += fmt.Sprintf("\"%s\",\"%s\"\n", chinese, english)
    }

    return csvContent, nil
}
```

**导出格式**: 标准 CSV，包含标题行，字段用双引号包围

## 并发控制

### 读写锁机制

**文件位置**: `app.go` - App 结构体定义

**锁定义**:
```go
type App struct {
    ctx context.Context
    db  *sql.DB
    mu  sync.RWMutex  // 读写锁
}
```

**使用模式**:
- **读操作**: 使用 `a.mu.RLock()` / `a.mu.RUnlock()`
- **写操作**: 使用 `a.mu.Lock()` / `a.mu.Unlock()`

**示例**:
```go
// 读操作 - 允许并发读
func (a *App) GetAllRoots() (map[string]string, error) {
    a.mu.RLock()
    defer a.mu.RUnlock()
    // ... 查询操作
}

// 写操作 - 互斥访问
func (a *App) AddRoot(chinese, english string) error {
    a.mu.Lock()
    defer a.mu.Unlock()
    // ... 插入操作
}
```

## 数据完整性保障

### 1. 主键约束
- `chinese` 字段作为主键，确保词根唯一性
- 防止重复词根插入

### 2. 非空约束
- `chinese` 和 `english` 字段都不能为 NULL
- 保证数据的完整性

### 3. 时间戳自动维护
- `created_at`: 记录创建时间，插入时自动设置
- `updated_at`: 记录更新时间，插入和更新时自动更新

### 4. 事务支持
- 批量操作使用事务确保原子性
- 错误时自动回滚

## 性能优化策略

### 1. 索引优化
- 主键自动索引
- 辅助索引 `idx_chinese` 优化查询性能

### 2. 查询优化
- 使用预编译语句
- 合理的查询条件
- 避免全表扫描

### 3. 连接管理
- 应用启动时建立数据库连接
- 连接在整个应用生命周期内保持
- 避免频繁连接断开

## 数据备份与恢复

### 导出功能
通过 `ExportRoots()` 方法可以将所有数据导出为 CSV 格式，便于备份。

### 导入功能
通过 `ImportRoots()` 方法可以从 CSV 文件恢复数据。

### 文件级备份
由于使用 SQLite，可以直接备份 `rootify.db` 文件。

## 扩展性考虑

### 表结构扩展
如需扩展功能，可以添加新表或扩展现有表：

**可能的扩展字段**:
- `category` - 词根分类
- `frequency` - 使用频率
- `source` - 数据来源

**新表设计示例**:
```sql
CREATE TABLE word_categories (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT
);

ALTER TABLE word_roots ADD COLUMN category_id INTEGER;
```

### 性能扩展
当数据量增大时，可考虑：
- 分表策略
- 查询缓存
- 数据库连接池

## 数据示例

### 典型数据记录
```sql
INSERT INTO word_roots (chinese, english) VALUES
('交易', 'trade'),
('日期', 'date'),
('金额', 'amount'),
('账户', 'account'),
('余额', 'balance');
```

### 查询结果示例
```sql
SELECT * FROM word_roots ORDER BY chinese;
```

| chinese | english | created_at | updated_at |
|---------|---------|------------|------------|
| 交易 | trade | 2024-01-01 10:00:00 | 2024-01-01 10:00:00 |
| 日期 | date | 2024-01-01 10:00:00 | 2024-01-01 10:00:00 |
| 金额 | amount | 2024-01-01 10:00:00 | 2024-01-01 10:00:00 |

这个数据库设计说明文档详细描述了系统的数据存储方案，包括表结构、操作实现、并发控制和性能优化策略。